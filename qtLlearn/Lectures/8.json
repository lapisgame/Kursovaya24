{
    "index": 8,
    "title": "Лекция 8",
    "content": "<pre><b>Лекция 8</b><br><b>ООП (Объектно-Ориентированное Программирование)</b><br><i>(Как моделировать реальный мир в коде)</i><br><br><b>1. Основные понятия</b><br><b>Класс</b> — шаблон для создания объектов (например, класс Собака).<br><b>Объект</b> — экземпляр класса (например, конкретная собака «Шарик»).<br><b>Атрибуты</b> — переменные, описывающие объект (вес, возраст).<br><b>Методы</b> — функции, которые может выполнять объект (лаять, бежать).<br><br><b>2. </b><b>Создание</b><b> </b><b>класса</b><br>class Cat:<br>    # Конструктор (вызывается при создании объекта)<br>    def __init__(self, name, age):<br>        self.name = name  # Атрибут объекта<br>        self.age = age<br><br>    # Метод<br>    def meow(self):<br>        print(f\"{self.name} говорит: Мяу!\")<br><br># Создание объекта<br>my_cat = Cat(\"Барсик\", 3)<br>my_cat.meow()  # Барсик говорит: Мяу!<br><b>Пояснение:</b><br>self — ссылка на сам объект (как я в русском языке).<br>__init__ — метод-конструктор, инициализирует атрибуты.<br><br><b>3. Наследование</b><br>Создаем класс-потомок, который наследует атрибуты и методы родителя:<br>class Robot:<br>    def __init__(self, name):<br>        self.name = name<br><br>    def say_hello(self):<br>        print(f\"Я {self.name}. Приветствую!\")<br><br>class BattleRobot(Robot):  # Наследование<br>    def attack(self):<br>        print(f\"{self.name} атакует лазером!\")<br><br># Использование<br>terminator = BattleRobot(\"T-800\")<br>terminator.say_hello()  # Я T-800. Приветствую!<br>terminator.attack()     # T-800 атакует лазером!<br><br><b>4. Инкапсуляция и полиморфизм</b><br><b>Инкапсуляция</b> — сокрытие внутренней реализации:<br>class BankAccount:<br>    def __init__(self):<br>        self.__balance = 0  # Приватный атрибут (два подчеркивания)<br><br>    def deposit(self, amount):<br>        if amount > 0:<br>            self.__balance += amount<br><br>    def get_balance(self):<br>        return self.__balance<br><br>account = BankAccount()<br>account.deposit(100)<br>print(account.get_balance())  # 100<br># account.__balance = 200  # Ошибка! Нельзя изменить напрямую.<br><b>Полиморфизм</b> — одинаковые методы работают по-разному для разных классов:<br>class Dog:<br>    def sound(self):<br>        print(\"Гав!\")<br><br>class Duck:<br>    def sound(self):<br>        print(\"Кря!\")<br><br>def make_sound(animal):<br>    animal.sound()<br><br>make_sound(Dog())  # Гав!<br>make_sound(Duck()) # Кря!<br><br><b>5. Зачем нужно ООП?</b><br><b>Упрощение сложных систем</b> — объекты соответствуют сущностям реального мира.<br><b>Переиспользование кода</b> — наследование и композиция.<br><b>Сокрытие деталей</b> — пользователь класса не видит внутреннюю логику.<br><br><b>6. Практический пример: игра</b><br>class Character:<br>    def __init__(self, name, health):<br>        self.name = name<br>        self.health = health<br><br>    def take_damage(self, damage):<br>        self.health -= damage<br>        print(f\"{self.name} получил урон {damage}. Осталось здоровья: {self.health}\")<br><br>class Mage(Character):<br>    def cast_spell(self):<br>        print(f\"{self.name} бросает огненный шар!\")<br><br># Создаем персонажей<br>warrior = Character(\"Воин\", 100)<br>mage = Mage(\"Маг\", 80)<br><br>warrior.take_damage(20)  # Воин получил урон 20. Осталось здоровья: 80<br>mage.cast_spell()        # Маг бросает огненный шар!<br><br></pre>"
}